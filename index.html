<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transformer Decoder Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap');
        
        :root {
            --bg: #030712;
            --panel: #111827;
            --accent: #6366f1;
            --token: #10b981;
            --attn: #f59e0b;
            --resid: #ec4899;
        }

        body {
            font-family: 'Space+Grotesk', sans-serif;
            background-color: var(--bg);
            color: #f3f4f6;
            overflow: hidden;
        }

        .mono { font-family: 'JetBrains+Mono', monospace; }

        .glass {
            background: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .step-active {
            border-color: var(--accent);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.3);
        }

        #viz-canvas {
            image-rendering: -webkit-optimize-contrast;
            cursor: move;
        }

        /* Tooltip style */
        .tooltip {
            position: absolute;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.9);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            z-index: 100;
            display: none;
            border: 1px solid var(--accent);
        }
    </style>
</head>
<body class="flex h-screen w-screen">

    <div id="tooltip" class="tooltip"></div>

    <!-- Sidebar Controls -->
    <aside class="w-80 glass flex flex-col h-full z-20 shadow-2xl">
        <div class="p-6 border-b border-white/10">
            <h1 class="text-xl font-bold tracking-tight text-white flex items-center gap-2">
                <span class="text-indigo-500">GPT</span>Explorer
            </h1>
            <p class="text-xs text-gray-400 mt-1">Decoder-Only Architecture Viz</p>
        </div>

        <div class="flex-1 overflow-y-auto p-6 space-y-8">
            <!-- Input Section -->
            <section>
                <label class="text-[10px] font-bold uppercase tracking-widest text-indigo-400 mb-2 block">Prompt</label>
                <input id="promptInput" type="text" value="The cat sat" class="w-full bg-black/40 border border-white/10 rounded-md p-2 text-sm mono focus:outline-none focus:border-indigo-500">
                <button id="updateTokens" class="w-full mt-2 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-xs font-bold transition-all">RE-TOKENIZE</button>
            </section>

            <!-- Hyperparameters -->
            <section class="space-y-4">
                <label class="text-[10px] font-bold uppercase tracking-widest text-indigo-400 block">Model Hyperparams</label>
                
                <div class="space-y-3">
                    <div class="flex justify-between text-xs">
                        <span>Layers (N)</span>
                        <span id="layersVal" class="text-indigo-400">2</span>
                    </div>
                    <input type="range" id="layersRange" min="1" max="4" value="2" class="w-full accent-indigo-500">

                    <div class="flex justify-between text-xs">
                        <span>Heads (H)</span>
                        <span id="headsVal" class="text-indigo-400">4</span>
                    </div>
                    <input type="range" id="headsRange" min="1" max="8" value="4" class="w-full accent-indigo-500">
                </div>
            </section>

            <!-- Logic Legend -->
            <section class="p-4 rounded-lg bg-black/20 border border-white/5 space-y-3">
                <h3 class="text-xs font-bold text-gray-300">COMPONENT LEGEND</h3>
                <div class="flex items-center gap-2 text-xs">
                    <span class="w-3 h-3 rounded-full bg-emerald-500"></span>
                    <span>Tokens / Embeddings</span>
                </div>
                <div class="flex items-center gap-2 text-xs">
                    <span class="w-3 h-3 rounded-full bg-amber-500"></span>
                    <span>Causal Self-Attention</span>
                </div>
                <div class="flex items-center gap-2 text-xs">
                    <span class="w-3 h-3 rounded-full bg-pink-500"></span>
                    <span>Residual Path</span>
                </div>
            </section>
        </div>

        <!-- Animation Controls -->
        <div class="p-6 bg-black/40 border-t border-white/10 space-y-4">
            <div class="flex gap-2">
                <button id="playBtn" class="flex-1 py-2 bg-white text-black rounded font-bold text-xs hover:bg-gray-200">PLAY</button>
                <button id="stepBtn" class="px-4 py-2 border border-white/20 rounded font-bold text-xs hover:bg-white/10">STEP</button>
                <button id="resetBtn" class="px-3 py-2 border border-white/20 rounded font-bold text-xs hover:bg-white/10">â†º</button>
            </div>
            <div class="flex items-center justify-between text-[10px] text-gray-500">
                <span>SPEED</span>
                <input type="range" id="speedRange" min="0.1" max="2" step="0.1" value="1" class="w-24">
            </div>
        </div>
    </aside>

    <!-- Main Visualization Area -->
    <main class="flex-1 relative flex flex-col">
        <!-- Status Bar -->
        <div class="h-12 glass flex items-center px-6 justify-between text-xs font-medium z-10 border-b-0">
            <div id="stepDescription" class="text-indigo-300 italic">Initializing Transformer parameters...</div>
            <div id="stats" class="mono opacity-50">T: 0 | L: 0 | Heads: 0</div>
        </div>

        <!-- Canvas -->
        <div id="canvasWrapper" class="flex-1 bg-gray-950 overflow-hidden relative">
            <canvas id="viz-canvas"></canvas>
            
            <!-- Floating Output Overlay -->
            <div id="predictionUI" class="absolute top-6 right-6 w-56 glass p-4 rounded-xl shadow-2xl hidden transform translate-y-4 opacity-0 transition-all duration-500">
                <h4 class="text-[10px] font-bold text-indigo-400 uppercase tracking-widest mb-3">Next Token Pred</h4>
                <div id="probsList" class="space-y-2">
                    <!-- Probs injected here -->
                </div>
                <button id="autoregressBtn" class="w-full mt-4 py-2 bg-indigo-600 rounded text-[10px] font-bold hover:bg-indigo-500">APPEND & RE-RUN</button>
            </div>
        </div>
    </main>

    <script>
        const canvas = document.getElementById('viz-canvas');
        const ctx = canvas.getContext('2d');
        const wrapper = document.getElementById('canvasWrapper');
        const tooltip = document.getElementById('tooltip');

        // State
        let tokens = ["The", "cat", "sat"];
        let layersN = 2;
        let headsH = 4;
        let currentStep = 0;
        let isPlaying = false;
        let animationProgress = 0;
        let speed = 1.0;
        
        // Visual constants
        const LAYER_HEIGHT = 180;
        const TOKEN_GAP = 90;
        const BLOCK_WIDTH = 400;

        // View Matrix
        let camY = 0;
        let targetCamY = 0;

        const STEPS = [
            { id: 'embed', label: 'Token + Positional Embedding', detail: 'Converting tokens to high-dimensional vectors and adding sequence position info.' },
            { id: 'norm1', label: 'Layer Normalization', detail: 'Stabilizing activations before attention.' },
            { id: 'attn', label: 'Masked Self-Attention', detail: 'Each token "looks" at previous tokens to gather context.' },
            { id: 'resid1', label: 'Residual Connection', detail: 'Adding the input back to avoid vanishing gradients.' },
            { id: 'norm2', label: 'Layer Normalization', detail: 'Normalizing before the Feed-Forward block.' },
            { id: 'mlp', label: 'Feed-Forward Network (MLP)', detail: 'Expanding vectors and applying non-linearity for complex patterns.' },
            { id: 'resid2', label: 'Residual Connection', detail: 'Final residual skip for this block.' },
            { id: 'output', label: 'Linear Head & Softmax', detail: 'Projecting back to vocabulary space to predict the next token.' }
        ];

        function resize() {
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
        }

        function drawToken(x, y, label, isActive, val = 0) {
            ctx.save();
            ctx.translate(x, y);
            
            // Glow
            if (isActive) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#10b981';
            }

            // Box
            ctx.fillStyle = isActive ? '#10b981' : '#1e293b';
            ctx.strokeStyle = isActive ? '#fff' : '#334155';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.roundRect(-30, -15, 60, 30, 4);
            ctx.fill();
            ctx.stroke();

            // Label
            ctx.fillStyle = isActive ? '#000' : '#94a3b8';
            ctx.font = '12px "JetBrains Mono"';
            ctx.textAlign = 'center';
            ctx.fillText(label, 0, 4);

            ctx.restore();
        }

        function drawAttention(tokenIdx, layerBaseY, tokensList) {
            const x = canvas.width/2 - (tokensList.length-1) * TOKEN_GAP / 2 + tokenIdx * TOKEN_GAP;
            const baseY = layerBaseY;

            ctx.save();
            for(let i = 0; i <= tokenIdx; i++) {
                const startX = canvas.width/2 - (tokensList.length-1) * TOKEN_GAP / 2 + i * TOKEN_GAP;
                const strength = 0.2 + (Math.random() * 0.5); // Mock attention weight
                
                ctx.beginPath();
                ctx.moveTo(startX, baseY + 20);
                ctx.bezierCurveTo(startX, baseY + 60, x, baseY + 60, x, baseY + 20);
                ctx.strokeStyle = `rgba(245, 158, 11, ${strength})`;
                ctx.lineWidth = strength * 3;
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawBlock(y, label, isActive) {
            ctx.save();
            ctx.strokeStyle = isActive ? 'rgba(99, 102, 241, 0.4)' : 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.strokeRect(canvas.width/2 - BLOCK_WIDTH/2, y - 40, BLOCK_WIDTH, 120);
            
            ctx.setLineDash([]);
            ctx.fillStyle = isActive ? '#818cf8' : '#4b5563';
            ctx.font = '10px "Space Grotesk"';
            ctx.textAlign = 'left';
            ctx.fillText(label, canvas.width/2 - BLOCK_WIDTH/2 + 10, y - 25);
            ctx.restore();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Smooth Camera
            camY += (targetCamY - camY) * 0.1;
            ctx.save();
            ctx.translate(0, camY + canvas.height * 0.7);

            const startX = canvas.width/2 - (tokens.length - 1) * TOKEN_GAP / 2;

            // 1. Draw Embeddings (Bottom)
            const embedY = 0;
            const isEmbedActive = currentStep === 0;
            drawBlock(embedY, "EMBEDDING LAYER", isEmbedActive);
            tokens.forEach((t, i) => drawToken(startX + i * TOKEN_GAP, embedY, t, isEmbedActive));

            // 2. Draw Layers
            for(let n = 0; n < layersN; n++) {
                const layerY = -(n + 1) * LAYER_HEIGHT;
                const layerStepOffset = 1 + n * 6; // norm1, attn, resid1, norm2, mlp, resid2
                
                // Block Container
                const isBlockActive = currentStep >= layerStepOffset && currentStep < layerStepOffset + 6;
                drawBlock(layerY, `DECODER BLOCK #${n+1}`, isBlockActive);

                // Internal Components
                tokens.forEach((t, i) => {
                    const x = startX + i * TOKEN_GAP;
                    
                    // Show attention lines
                    if (currentStep === layerStepOffset + 2) { // 'attn' step
                        drawAttention(i, layerY, tokens);
                    }

                    // Tokens at this layer height
                    drawToken(x, layerY, t, isBlockActive);
                });
            }

            // 3. Output Head (Top)
            const outY = -(layersN + 1) * LAYER_HEIGHT;
            const isOutActive = currentStep === STEPS.length - 1;
            drawBlock(outY, "OUTPUT PROJECTION", isOutActive);
            tokens.forEach((t, i) => {
                const x = startX + i * TOKEN_GAP;
                const isLast = i === tokens.length - 1;
                drawToken(x, outY, t, isOutActive && isLast);
                
                // Prediction line from last token
                if (isOutActive && isLast) {
                    ctx.beginPath();
                    ctx.moveTo(x, outY - 20);
                    ctx.lineTo(x, outY - 60);
                    ctx.strokeStyle = '#6366f1';
                    ctx.setLineDash([2, 2]);
                    ctx.stroke();
                }
            });

            ctx.restore();

            if (isPlaying) {
                animationProgress += 0.01 * speed;
                if (animationProgress >= 1) {
                    animationProgress = 0;
                    stepForward();
                }
            }

            requestAnimationFrame(render);
        }

        function updateStepUI() {
            const step = STEPS[currentStep];
            document.getElementById('stepDescription').innerText = step.detail;
            document.getElementById('stats').innerText = `T: ${tokens.length} | L: ${layersN} | H: ${headsH} | Step: ${currentStep + 1}/${STEPS.length}`;
            
            // Adjust camera to look at the active component
            if (currentStep === 0) targetCamY = 0;
            else if (currentStep === STEPS.length - 1) targetCamY = (layersN + 1) * LAYER_HEIGHT;
            else {
                const layerIndex = Math.floor((currentStep - 1) / 6);
                targetCamY = (layerIndex + 1) * LAYER_HEIGHT;
            }

            // Show prediction overlay if finished
            const predUI = document.getElementById('predictionUI');
            if (currentStep === STEPS.length - 1) {
                predUI.classList.remove('hidden');
                setTimeout(() => {
                    predUI.classList.add('translate-y-0', 'opacity-100');
                    generateProbs();
                }, 100);
            } else {
                predUI.classList.remove('translate-y-0', 'opacity-100');
                setTimeout(() => predUI.classList.add('hidden'), 500);
            }
        }

        function stepForward() {
            if (currentStep < STEPS.length - 1) {
                currentStep++;
            } else {
                isPlaying = false;
                document.getElementById('playBtn').innerText = 'PLAY';
            }
            updateStepUI();
        }

        function generateProbs() {
            const vocab = ["down", "on", "quietly", "there", "fast"];
            const list = document.getElementById('probsList');
            list.innerHTML = '';
            
            vocab.forEach((word, i) => {
                const p = (Math.random() * (1 - i*0.15)).toFixed(2);
                const div = document.createElement('div');
                div.className = "flex items-center justify-between text-xs";
                div.innerHTML = `
                    <span class="mono">${word}</span>
                    <div class="flex-1 mx-2 h-1.5 bg-white/5 rounded-full overflow-hidden">
                        <div class="h-full bg-indigo-500" style="width: ${p*100}%"></div>
                    </div>
                    <span class="mono opacity-60 text-[10px]">${p}</span>
                `;
                list.appendChild(div);
            });
        }

        // Interaction Handlers
        document.getElementById('updateTokens').onclick = () => {
            const input = document.getElementById('promptInput').value;
            tokens = input.trim().split(/\s+/).slice(0, 8); // Limit for viz clarity
            currentStep = 0;
            updateStepUI();
        };

        document.getElementById('layersRange').oninput = (e) => {
            layersN = parseInt(e.target.value);
            document.getElementById('layersVal').innerText = layersN;
            currentStep = 0;
            updateStepUI();
        };

        document.getElementById('headsRange').oninput = (e) => {
            headsH = parseInt(e.target.value);
            document.getElementById('headsVal').innerText = headsH;
        };

        document.getElementById('speedRange').oninput = (e) => {
            speed = parseFloat(e.target.value);
        };

        document.getElementById('playBtn').onclick = (e) => {
            isPlaying = !isPlaying;
            e.target.innerText = isPlaying ? 'PAUSE' : 'PLAY';
        };

        document.getElementById('stepBtn').onclick = () => {
            isPlaying = false;
            document.getElementById('playBtn').innerText = 'PLAY';
            stepForward();
        };

        document.getElementById('resetBtn').onclick = () => {
            currentStep = 0;
            animationProgress = 0;
            isPlaying = false;
            document.getElementById('playBtn').innerText = 'PLAY';
            updateStepUI();
        };

        document.getElementById('autoregressBtn').onclick = () => {
            const nextWord = document.querySelector('#probsList .mono').innerText;
            const input = document.getElementById('promptInput');
            input.value += " " + nextWord;
            document.getElementById('updateTokens').click();
        };

        // Initialize
        window.addEventListener('resize', resize);
        resize();
        updateStepUI();
        render();

    </script>
</body>
</html>

